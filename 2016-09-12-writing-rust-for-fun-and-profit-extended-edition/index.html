<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Writing Ruby+Rust for fun and profit!</title><meta charset="UTF-8"></meta><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="hovercraft.css" media="screen,projection"></link><script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        showProcessingMessages: false,
        messageStyle: "none",
        TeX : { extensions : ['color.js'] }
      });
    </script></head><body class="impress-not-supported"><div id="impress"><div class="step step-level-1" step="0" id="title-card" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="writing-ruby-rust-for-fun-and-profit">Writing Ruby+Rust for Fun and Profit!</h1><a href="http://www.rustacean.net/"><img src="images/rustacean-with-ruby.png" alt="[Rustacean with a Ruby in its claw]" width="50%" class="rustacean"></img></a><p>Presenter: Mark Lee - Pythonista, Rustacean, and Professional Rubyist</p><p>September 12, 2016</p><div class="notes"><p>Hi, I'm Mark, and I'm going to talk about my journey to get Rust into production at my job.</p></div></div><div class="step step-level-1" step="1" id="whoami" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="who-am-i">Who am I?</h1><ul><li>Software Engineer at <a href="https://data-axle.com/"><img src="images/data-axle.png" alt="Data Axle" height="30px" class="inline"></img></a></li><li>Ruby by day, everything else by night</li></ul><div class="notes"><p>I work in Fremont at Data Axle, a tech division of Infogroup, which is a company that you
haven't heard of unless you happen to be in the local business listings industry. Although
chances are pretty good that you've used our data on some digital map or GPS unit when you're
looking for some business or if they're open. Anyway, we're primarily a Rails shop, so I write
mostly Ruby during the day.</p></div></div><div class="step step-level-1" step="2" id="languages" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><a href="https://www.openhub.net/accounts/malept/languages"><img src="images/openhub-languages-20160911.png" alt="[Languages used in open source projects]"></img></a><div class="notes"><p>In my off hours, you could say that I'm a bit of a polyglot.</p></div></div><div class="step step-level-1" step="3" id="extensions" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="extensions">Extensions</h1><div class="notes"><p>A fair percentage of that code are bindings or extensions to another language. I did make a
small web app with Hyper, but I decided that writing a native Ruby extension in Rust would be a
better way to ease my team into the idea of adding Rust into our ecosystem.</p></div></div><div class="step step-level-1" step="4" id="extensions-pros" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="pros">Pros</h1><ul><li>Avoid reinventing the wheel</li><li>Speed up hotspots</li></ul><div class="notes"><p>Very briefly, here are the pros and cons of native extensions in general. I've found that I can
avoid reinventing the wheel if I just bind a native library to my language of choice. My first
native extension was actually binding the reference C implementation of the tiger tree hash so
that I could use it in a Python desktop app I was writing. The more popular reason to use an
extension is to speed up either CPU- or RAM-bound areas in your code.</p></div></div><div class="step step-level-1" step="5" id="extensions-cons" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="cons">Cons</h1><ul><li>Takes longer to develop</li><li>Lower <a href="https://en.wikipedia.org/wiki/Bus_factor">bus factor</a></li></ul><div class="notes"><p>One of the downsides is that it takes longer to write. You can't really get away from that,
unless your native programming language is so magical that it writes exactly like a higher-level
language - Rust comes close, but not <em>that</em> close. The other big downside is related to the
previous one - there's a lower bus factor due to the relatively higher complexity of a native
programming language.</p></div></div><div class="step step-level-1" step="6" id="escape_hstore" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="case-study-escape-hstore">Case study: <tt>escape_hstore</tt></h1><ul><li>Rails (ActiveRecord+PostgreSQL) monkeypatch</li></ul><div class="notes"><p>My first attempt at a Rust extension for work was a little over a year ago. I was in the middle of refactoring an ETL project (extract, transform, load) and I was experimenting with outputting the result of the extract stage into PostgreSQL. My thought was to use the HSTORE extension, which is basically PostgreSQL's first attempt at a key-value store. I wanted to avoid column changes when the data layout changed. (These days, people tend to use PostgreSQL's binary json column, but this was before we had production access to a Postgres database with that feature.) The problem was that when I profiled it with a significant number of records, Rails's ActiveRecord implementation of serializing data into HSTORE SQL was a fairly big bottleneck. I really didn't want to write a pure C extension to handle this. I knew that if tried to add it to our system, the odds are it wouldn't make it due to the downsides I mentioned earlier. Also, I didn't really want to write all of that boilerplate memory management code, plus all of the extra build system work, because I would need at least a third party regular expression library. On the other hand, I had read about Rust, so I decided to take about a day and see if that would do what I wanted.</p></div></div><div class="step step-level-1" step="7" id="escape_hstore-attempt-1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="escape-hstore-attempt-1"><tt>escape_hstore</tt>: Attempt 1</h1><ul><li>Tied to nightly <tt>rustc</tt></li><li>Partly written in C</li></ul><div class="notes"><p>The result was that I got something working, and it was somewhat faster than the pure Ruby version, but it was using the nightly version of Rust (because I had it in my head that I needed the <tt>regex!</tt> macro for speed), it was partly written in C (as the glue between Rust and Ruby), and I ran into other problems with HSTORE orthogonal to the extension, so it was put aside. After this experiment, it took me a couple more tries within the next year to get it working a) noticeably faster, and b) using a stable compiler. Among other things, I replaced the <tt>regex!</tt> macro with the <tt>lazy_static!</tt> macro, and also fixed a memory leak in my C glue code.</p></div></div><div class="step step-level-1" step="8" id="escape_hstore-benchmarks" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="current-benchmark">Current Benchmark</h1><table cellpadding="0" cellspacing="0"><thead><tr><th><p>Benchmark</p></th><th><p>Run 1</p></th><th><p>Run 2</p></th><th><p>Run 3</p></th><th><p>Run 4</p></th><th><p>Run 5</p></th></tr></thead><tbody><tr><td><p><strong>Rails</strong></p></td><td><p>0.393944</p></td><td><p>0.396805</p></td><td><p>0.396090</p></td><td><p>0.400217</p></td><td><p>0.400597</p></td></tr><tr><td><p><strong>Rust</strong></p></td><td><p>0.302957</p></td><td><p>0.306831</p></td><td><p>0.303744</p></td><td><p>0.301019</p></td><td><p>0.299960</p></td></tr></tbody></table><ul><li>Specs: AWS EC2 t2.medium, Ubuntu Linux 16.04 (amd64), Ruby 2.3.1, Rust 1.11.0</li><li>TL;DR: ~25% speedup</li></ul><div class="notes"><p>I gave a talk at work about this, and my notes say that I wanted to see if I could rewrite it in this project called "turboruby", which by the next RailsConf would turn out to be "Helix". I would end up replacing the glue code with ruru, which has better docs and is overall better maintained. These are the current benchmarks.</p></div></div><div class="step step-level-1" step="9" id="escape_hstore-code" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="code">[Code]</h1></div><div class="step step-level-1" step="10" id="interlude" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="interlude">Interlude</h1><blockquote><p>Ruby doesn't really have a "C extension API" as much as it has "please link against my internals
thanks."</p></blockquote><div class="cite"><span class="cite_label">Source: </span><cite><a href="https://github.com/steveklabnik/rust_example#why-all-the-mess">Steve Klabnik</a></cite></div><div class="notes"><p>As an aside, in working on porting the extension to use Ruru, I was repeatedly reminded of this
quote. I've hacked and/or written native extensions for three languages now, and by far, Ruby
has the worst "interface". It is absolutely ridiculous a) how bad the docs are, and b) how many
static functions and preprocessor macros are used. It turns out the Ruby value type code is
almost all preprocessor macros, which is not FFI-friendly.</p></div></div><div class="step step-level-1" step="11" id="rust-ruby-integration" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><h1 id="making-rust-ruby-integration-better">Making Rust+Ruby integration better</h1><ul><li>Problem: adding a new dependency</li><li>Solution: &#x2026;?</li></ul><div class="notes"><p>In writing the extension, I was thinking about what it would take to get it into production. I
was worried about two faces of the same coin: adding a new dependency. From a developer's
perspective, that means that if you update the app with a required Rust extension, you need to
tell all of the developers how to install and possibly configure Rusti/Cargo on their computer.
Admittedly, even with <tt>multirust</tt>, it wasn't that bad. But it's still an interrupt on their
normal routine.</p><p>The case that I was more worried about was adding a Rust dependency in production. For various
reasons, we're not using containers at the moment. I really didn't want to add a Rust compiler
on all of the production machines, because that would cause my DevOps coworker to start
grumbling, and my general philosophy has been to keep DevOps generally&#x2026; not annoyed. So I
started to design a way to install gems with Rust extensions without needing a Rust
installation. And I came up with&#x2026;</p></div></div><div class="step step-level-1" step="12" id="thermite" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><h1 id="thermite">Thermite</h1><p><blockquote class="imgur-embed-pub" lang="en" data-id="NzXAzNK">Example of Thermite</blockquote><script async src="//s.imgur.com/min/embed.js" charset="utf-8"></script></p><p>(<a href="https://redd.it/3aiu78">Reddit source</a>, <a href="https://youtu.be/tj7S_DNFgEU?t=3m52s">YouTube source</a>)</p><div class="notes"><p>I named the gem "thermite". One of the reasons may have been an excuse to watch a bunch of
chemical reaction videos.</p></div></div><div class="step step-level-1" step="13" id="why-thermite" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><h1 id="why-name-it-thermite">Why name it Thermite?</h1><ul><li>Ruby includes aluminum oxide (Al&#x2082;O&#x2083;)</li><li>Rust: iron oxide (Fe&#x2082;O&#x2083;)</li><li>A common thermite formula: Fe&#x2082;O&#x2083; + 2Al &#x2192; 2Fe + Al&#x2082;O&#x2083;</li></ul><div class="notes"><p>But really, why name it Thermite? A cheap shot at humor. According to Wikipedia, Ruby (the
gemstone) contains aluminum oxide. Rust (the orange stuff) is iron oxide. A common thermite
reaction uses iron oxide and aluminum to produce iron and aluminum oxide. Also, somehow the gem
name "thermite" wasn't taken.</p></div></div><div class="step step-level-1" step="14" id="what-is-thermite" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><h1 id="seriously-though-what-is-it">Seriously though, what is it?</h1><blockquote><p><a href="https://github.com/malept/thermite">Thermite</a> is a Rake-based helper for building and
distributing Rust-based Ruby extensions.</p></blockquote><div class="notes"><p>Now that I've thoroughly explained the joke, I might as well describe what it does. The easiest
way to do that is to quote the README.</p></div></div><div class="step step-level-1" step="15" id="thermite-features" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="24000" data-y="0" data-z="0"><h1 id="thermite-features">Thermite: Features</h1><ul><li>Make it easy to configure and run <tt>cargo</tt></li><li>Install the compiled extension in a location easily accessible by Ruby</li><li>Allow users to install precompiled binaries from GitHub releases (or an arbitrary URL - coming soon)</li></ul><div class="notes"><p>Although it's primarily a wrapper around <tt>cargo</tt>, the other big feature is that it allows the
library developer to specify a location where users will automatically download and install
precompiled versions of the extension, if <tt>cargo</tt> is not on their system. This is particularly
useful when you don't want to impose a new language dependency on all of the developers, or the
production infrastructure.</p></div></div><div class="step step-level-1" step="16" id="six-easy-steps" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25600" data-y="0" data-z="0"><h1 id="use-thermite-in-six-easy-steps">Use Thermite in Six Easy Steps!</h1><ol><li>Add <tt>thermite</tt> to your <tt>Gemfile</tt>, run <tt>bundle</tt></li><li>Add to your gemspec:<pre class="highlight code ruby"><span class="n">s</span><span class="o">.</span><span class="n">extensions</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s1">'ext/Rakefile'</span><span class="w">
</span><span class="n">s</span><span class="o">.</span><span class="n">add_runtime_dependency</span><span class="w"> </span><span class="s1">'thermite'</span><span class="p">,</span><span class="w"> </span><span class="s1">'~&gt; 0'</span></pre></li><li>Create <tt>ext/Rakefile</tt>:<pre class="highlight code ruby"><span class="nb">require</span><span class="w"> </span><span class="s1">'thermite/tasks'</span><span class="w">
</span><span class="no">Thermite</span><span class="o">::</span><span class="no">Tasks</span><span class="o">.</span><span class="n">new</span></pre></li><li>Load your extension via FFI + Thermite</li><li>?</li><li><del>Profit!</del> Performance!</li></ol><div class="notes"><p>I've tried to make it relatively simple to use. Add a gem, create a few files, some magic
happens, and you're ready to write some fast code! Like a good project, the gem itself has
unit tests, API docs, and hopefully a fairly comprehensive README.</p></div></div><div class="step step-level-1" step="17" id="case-study-transliteration" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="27200" data-y="0" data-z="0"><h1 id="case-study-transliteration">Case Study: Transliteration</h1><div class="notes"><p>Since I wrote Thermite, I felt like I needed to write a gem that I could use to show concretely
that we can add Rust to our ecosystem. The <tt>escape_hstore</tt> extension was nice, but we weren't
actually using it. This past week, I found an area that could be easily sped up by Rust:
transliteration.</p></div></div><div class="step step-level-1" step="18" id="defining-transliteration" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="28800" data-y="0" data-z="0"><h1 id="utf-8-ascii">UTF-8 &#x2192; ASCII</h1><ul><li><tt>&#xE9;</tt> &#x2192; <tt>e</tt></li><li><tt>&#x2014;</tt> &#x2192; <tt>-</tt></li><li><tt>&#xAE;</tt> &#x2192; <tt>(R)</tt></li></ul><div class="notes"><p>I should define what I mean by transliteration. In this case, it's the process taking characters
outside of the ASCII character set and converting them into their ASCII "equivalent". For
example, European characters with accents lose the accents, and traditional Chinese characters
get converted to their pinyin equivalents. In this case, it's usually accented characters and
punctuation that needs to get converted. We need to do this because we talk to systems outside
of our control that only use the ASCII character set.</p></div></div><div class="step step-level-1" step="19" id="i18n-gem" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="30400" data-y="0" data-z="0"><h1 id="i18n"><tt>i18n</tt></h1><ul><li>Dependency of ActiveSupport</li><li>Pure Ruby</li></ul><pre class="highlight code ruby"><span class="no">I18n</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">store_translations</span><span class="p">(</span><span class="ss">:en</span><span class="p">,</span><span class="w"> </span><span class="ss">i18n</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="ss">transliterate</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="ss">rule</span><span class="p">:</span><span class="w"> </span><span class="n">custom_translations</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="p">})</span><span class="w">
</span><span class="no">I18n</span><span class="o">.</span><span class="n">transliterate</span><span class="p">(</span><span class="n">input_string</span><span class="p">)</span></pre><div class="notes"><p>How does Rails help us with that? Part of Rails is this gem called ActiveSupport, which has a
bunch of convenience methods and configurations that aren't in the Ruby standard library. It
includes a dependency on the <tt>i18n</tt> gem, which is preconfigured so that we can transliterate
strings with accented characters with a simple method call. If you want custom transliterations,
it's slightly more work, but not too bad, as you can see.</p></div></div><div class="step step-level-1" step="20" id="i18n-profile" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="32000" data-y="0" data-z="0"><h1 id="i18n-profile"><tt>i18n</tt> Profile</h1><pre class="highlight ">allocated memory by file
-----------------------------------
[...]
6266676  RUBY/openssl/buffering.rb
6086560  GEMS/i18n-0.7.0/lib/i18n/backend/base.rb
5742584  GEMS/activesupport-4.2.5/lib/active_support/dependencies.rb
5291777  GEMS/i18n-0.7.0/lib/i18n/backend/transliterator.rb
[...]</pre><div class="notes"><p>I've been helping a coworker with some optimizations lately, in particular, related to
memory allocation. When I was looking at the memory profiler output, I noticed that the <tt>i18n</tt>
gem allocated and retained more memory than I was expecting, so I dug into it. It turns out that
<tt>i18n</tt>'s <tt>transliterate</tt> runs a Regexp replace with a method callback, and iterates
character-by-character to see which ones need to be replaced. This allocates at least one object
per character, which can get bad when you're running this on lots of large records.</p></div></div><div class="step step-level-1" step="21" id="t12r" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="33600" data-y="0" data-z="0"><h1 id="enter-t12r">Enter: T12r</h1><ul><li>Transliterator &#x2192; T12r</li><li>Rust: 45 LoC (not including tests)</li><li>Ruby: 27 LoC (not including tests)</li></ul><pre class="highlight code ruby"><span class="no">T12r</span><span class="o">.</span><span class="n">transliterate</span><span class="p">(</span><span class="n">input_string</span><span class="p">,</span><span class="w"> </span><span class="n">custom_translations</span><span class="p">)</span></pre><div class="notes"><p>Since the bottleneck wasn't in our code, I decided to port transliterate to Rust, monkeypatch
the <tt>i18n</tt> gem, and see what kind of speedup I get. Luckily for me, someone wrote a Rust crate
to transliterate Unicode (rust-unidecode). The only thing I had to write, apart from the minimal
ruru glue code, was support for "custom translations", which was pretty trivial - convert a Ruby
hash into a Rust hash. All in all, it did not end up being that much code, less than 100
lines total.</p></div></div><div class="step step-level-1" step="22" id="t12r-code" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="35200" data-y="0" data-z="0"><h1 id="code-1">[Code]</h1></div><div class="step step-level-1" step="23" id="t12r-profile" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="36800" data-y="0" data-z="0"><h1 id="t12r-profile"><tt>t12r</tt> Profile</h1><pre class="highlight ">allocated memory by file
-----------------------------------
[...]
6486233  RUBY/openssl/buffering.rb
6086560  GEMS/i18n-0.7.0/lib/i18n/backend/base.rb
5742584  GEMS/activesupport-4.2.5/lib/active_support/dependencies.rb
[... 11 other files ...]
2692249  T12R/lib/t12r/i18n_monkeypatch.rb
[...]

From the baseline profile earlier:
5291777  GEMS/i18n-0.7.0/lib/i18n/backend/transliterator.rb</pre><div class="notes"><p>Turns out when I monkeypatch the <tt>i18n</tt> gem, the memory it allocates is cut very nearly
in half.</p></div></div><div class="step step-level-1" step="24" id="t12r-benchmarks" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="38400" data-y="0" data-z="0"><h1 id="benchmarks">Benchmarks</h1><table cellpadding="0" cellspacing="0"><thead><tr><th><p>Benchmark</p></th><th><p>Run 1</p></th><th><p>Run 2</p></th><th><p>Run 3</p></th><th><p>Run 4</p></th><th><p>Run 5</p></th></tr></thead><tbody><tr><td><p>activesupport_unrealistic</p></td><td><p>9.229482</p></td><td><p>9.244237</p></td><td><p>9.207310</p></td><td><p>9.214158</p></td><td><p>9.303218</p></td></tr><tr><td><p>t12r_unrealistic</p></td><td><p>0.737353</p></td><td><p>0.736112</p></td><td><p>0.734379</p></td><td><p>0.737035</p></td><td><p>0.734893</p></td></tr><tr><td><p>activesupport_realistic</p></td><td><p>0.640747</p></td><td><p>0.632533</p></td><td><p>0.634910</p></td><td><p>0.636180</p></td><td><p>0.638756</p></td></tr><tr><td><p>t12r_realistic</p></td><td><p>0.315267</p></td><td><p>0.317564</p></td><td><p>0.315769</p></td><td><p>0.319236</p></td><td><p>0.316022</p></td></tr></tbody></table><ul><li>Specs: AWS EC2 t2.medium, Ubuntu Linux 16.04 (amd64), Ruby 2.3.1, Rust 1.11.0</li><li>Unrealistic benchmark (~13x speedup&#x203D;): 220 characters, 70% non-ASCII</li><li>Realistic benchmark (~2x speedup):<blockquote><p>Introducing: Slurm&#xAE; Latt&#xE9;&#x2014;Even more highly addictive!</p></blockquote></li></ul><div class="notes"><p>Unfortunately running the memory profile script makes it more difficult to figure out if there
are any speedups, so I wrote a quick benchmark script. It actually does two benchmarks - one
with mostly special characters, and one with mostly normal characters. The special character
benchmark was surprising, it was consistently around a 13x speedup. On the other hand, the
benchmark with the more realistic text was closer to a 2x speedup. Not bad for less than 100
lines of code. I presented these last few slides last Friday more or less verbatim, and it looks
like I got the go-ahead to start integrating this gem into our system.</p></div></div><div class="step step-level-1" step="25" id="questions" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="40000" data-y="0" data-z="0"><h1 id="questions">Questions?</h1></div></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/gotoSlide.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>