<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title><meta charset="UTF-8"></meta><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="hovercraft.css" media="screen,projection"></link><script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        showProcessingMessages: false,
        messageStyle: "none",
        TeX : { extensions : ['color.js'] }
      });
    </script></head><body class="impress-not-supported"><div id="impress"><div class="step step-level-1" step="0" id="title-card" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="writing-rust-for-fun-profit">Writing Rust for Fun (&amp; Profit?)</h1><h2 id="episode-v-the-memory-safety-strikes-back">Episode V: The Memory Safety Strikes Back</h2><a href="http://www.rustacean.net/"><img src="images/rustacean-orig-trans.png" alt="[Rustacean]" width="50%" class="rustacean"></img></a><p>Presenter: Mark Lee, Pythonista, Sometimes-Rubyist, and Novice Rustacean</p><p>May 06, 2016</p><div class="notes"><p>Today I'm going to continue with my series on why Rust is awesome and why we should use it. In
particular, I'm going to address a few things that I didn't have time to talk about last time,
and also some status updates.</p></div></div><div class="step step-level-1" step="1" id="previously" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="previously-on-the-rust-wing">Previously on The Rust Wing&#x2026;</h1><p><em>drumroll</em></p><img src="images/the-rust-wing.png" alt="[The Rust Wing]" width="75%"></img><div class="notes"><p>In our last episode, we learned that Rust is a systems programming language, around 6 years old,
with a bunch of interesting features like memory safety and a modern syntax I showed off some
example code and two use cases: a speedup extension for Ruby, and a very simple webapp, both
with benchmarks.</p></div></div><div class="step step-level-1" step="2" id="rust-news" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="what-s-happened-in-the-rust-ecosystem">What's happened in the Rust ecosystem?</h1><ul><li><a href="http://blog.rust-lang.org/2016/04/14/Rust-1.8.html">Rust 1.8</a></li><li><a href="http://www.wired.com/2016/03/epic-story-dropboxs-exodus-amazon-cloud-empire/">Dropbox article</a> in <em>Wired</em></li><li>Rust's <tt>regex</tt> crate + C &#x2192; <a href="https://github.com/BurntSushi/rure-go">Rust regexes in Go</a></li></ul><div class="notes"><p>Generally speaking, Rust 1.7 and then 1.8 were released in between talks. Given the project's
six week release cycle, this isn't too surprising. A fair amount of the changes were related to
stabilization of standard library functions.</p><p>There's been some interesting third-party news since the last talk. Dropbox finally went public
with how they're using Rust: they rewrote parts of their distributed filesystem (called "Magic
Pocket") from Go. Their reasons included memory usage/control, easy FFI, and code
safety/correctness.</p><p>Speaking of Go, the author of the regular expression package for Rust recently wrote C bindings
for it. To test them, he wrote a package that provides that regex engine to Go.</p></div></div><div class="step step-level-1" step="3" id="cargo" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="missing-topic-cargo">Missing Topic: Cargo</h1><a href="https://crates.io"><img src="images/Cargo-Logo-Small.png" alt="[Cargo Logo]"></img></a><div class="notes"><p>One of the topics I missed last time was on package management. Rust does have it! The manager
app is called <tt>cargo</tt>, the packages are called crates, and the package index website lives at
crates.io. Given that there are some prominent Rubyists working on this, it should not surprise
you to learn that it is pretty similar to RubyGems and Bundler. You create a new Rust project by
running <tt>cargo new</tt> (which is kind of similar to <tt>rails new</tt>), you build the project with
<tt>cargo build</tt>, you update the dependencies with <tt>cargo update</tt> (which updates a <tt>.lock</tt>
file), and you publish a crate with <tt>cargo publish</tt>. All very familiar commands.</p></div></div><div class="step step-level-1" step="4" id="ruru" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="ruru">Ruru</h1><a href="https://github.com/d-unseductable/ruru"><img src="images/ruru.png" alt="[Ruru README screenshot]"></img></a><div class="notes"><p>This is probably the most relevant topic. Last week, a Lithuanian developer released a crate
that made it orders of magnitude easier to write Ruby extensions in Rust. This includes the
ability to monkeypatch methods directly in Rust. Naturally, I jumped at the chance to stop
writing C shims to get my Rust extensions to work. As I started to work on this project, there
was a nagging voice in the back of my head that was saying, "Don't make everyone (including the
app servers) have to download and install Rust if they don't need to!" So now I had two goals:
make the Ruby gem download binary libraries if Rust isn't installed, and remove the C component
of existing Rust-based extensions.</p></div></div><div class="step step-level-1" step="5" id="optional-rustc" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="step-1-optional-rustc">Step 1: Optional <tt>rustc</tt></h1><a href="https://github.com/malept/rusty_blank"><img src="images/rusty_blank.png" alt="[rusty_blank GitHub release]" width="100%"></img></a><div class="notes"><p>For step 1, I used the canonical example of a Rust-based Ruby extension: <tt>String.blank?</tt>.</p><p>After a few nights of experimentation, I came up with a Rake task that built the Rust library if
Cargo was found, and if not, it would download the latest tagged release on GitHub for the given
OS and architecture. GitHub binary releases are compiled and uploaded via Travis CI.</p></div></div><div class="step step-level-1" step="6" id="decification" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="step-2-de-cification">Step 2: De-Cification</h1><h2 id="before">Before</h2><table cellpadding="0" cellspacing="0"><thead><tr><th><p>Language</p></th><th><p>files</p></th><th><p>blank</p></th><th><p>comment</p></th><th><p>code</p></th></tr></thead><tbody><tr><td><p><em>Ruby</em></p></td><td><p>5</p></td><td><p>17</p></td><td><p>11</p></td><td><p>84</p></td></tr><tr><td><p><em>Rust</em></p></td><td><p>2</p></td><td><p>22</p></td><td><p>4</p></td><td><p>77</p></td></tr><tr><td><p><em>C</em></p></td><td><p>1</p></td><td><p>8</p></td><td><p>0</p></td><td><p>45</p></td></tr><tr><td><p><em>make</em></p></td><td><p>1</p></td><td><p>9</p></td><td><p>1</p></td><td><p>24</p></td></tr><tr><td><p><strong>SUM</strong></p></td><td><p>9</p></td><td><p>56</p></td><td><p>16</p></td><td><p>230</p></td></tr></tbody></table><h2 id="after">After</h2><table cellpadding="0" cellspacing="0"><thead><tr><th><p>Language</p></th><th><p>files</p></th><th><p>blank</p></th><th><p>comment</p></th><th><p>code</p></th></tr></thead><tbody><tr><td><p><em>Ruby</em></p></td><td><p>4</p></td><td><p>15</p></td><td><p>4</p></td><td><p>89</p></td></tr><tr><td><p><em>Rake</em></p></td><td><p>1</p></td><td><p>8</p></td><td><p>1</p></td><td><p>89</p></td></tr><tr><td><p><em>Rust</em></p></td><td><p>2</p></td><td><p>22</p></td><td><p>3</p></td><td><p>86</p></td></tr><tr><td><p><strong>SUM</strong></p></td><td><p>7</p></td><td><p>45</p></td><td><p>8</p></td><td><p>264</p></td></tr></tbody></table><div class="notes"><p>The second step was a bit more difficult. I ported the <tt>escape_hstore</tt> extension that I talked
about last time. Due to the immaturity of the ruru crate, I ended up contributing a few
features, including determining the type of Ruby values. In the end, if you ignore the build
system code from the previous step, I ended up with net negative, more concise code in the
extension, as you can see from the lines of code counter that I ran.</p></div></div><div class="step step-level-1" step="7" id="interlude" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="interlude">Interlude</h1><blockquote><p>Ruby doesn't really have a "C extension API" as much as it has "please link against my internals
thanks."</p></blockquote><div class="cite"><span class="cite_label">Source: </span><cite><a href="https://github.com/steveklabnik/rust_example#why-all-the-mess">Steve Klabnik</a></cite></div><div class="notes"><p>As an aside, in working on porting the extension to use Ruru, I was repeatedly reminded of this
quote. I've hacked and/or written native extensions for three languages now, and by far, Ruby
has the worst "interface". It is absolutely ridiculous a) how bad the docs are, and b) how many
static functions and preprocessor macros are used. It turns out the Ruby value type code is
almost all preprocessor macros, which is not FFI-friendly.</p></div></div><div class="step step-level-1" step="8" id="benchmarks" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="benchmarks-take-2">Benchmarks, Take 2</h1><p>Rust 1.8, Ruby 2.3.1, Linux x86_64 <em>(Lenovo Yoga, Intel i7-4600U @ 2.10GHz, 8GB RAM)</em></p><table cellpadding="0" cellspacing="0"><tbody><tr><td><p><strong>Rails</strong></p></td><td><p>0.339727</p></td><td><p>0.329724</p></td><td><p>0.327690</p></td><td><p>0.329705</p></td><td><p>0.326349</p></td></tr><tr><td><p><strong>Rust+C</strong></p></td><td><p>0.215731</p></td><td><p>0.212838</p></td><td><p>0.217413</p></td><td><p>0.215455</p></td><td><p>0.214668</p></td></tr><tr><td><p><strong>Ruru</strong></p></td><td><p>0.220376</p></td><td><p>0.218860</p></td><td><p>0.225751</p></td><td><p>0.217728</p></td><td><p>0.219013</p></td></tr></tbody></table><p>~35% speedup, difference between Rust + C hybrid &amp; Ruru negligible</p><div class="notes"><p>This project gave me an opportunity to redo my extension's benchmarks. My first set were a bit
problematic, primarily because I was running on a pretty old version of Ruby on my personal
laptop (which happens to be the default version of Ruby on Debian stable). I redid it with the
latest Rust, Ruby, and crate dependencies, and it turns out that the original benchmark was only
off by ~5%. Additionally, converting to pure Rust had a negligible speed cost.</p></div></div><div class="step step-level-1" step="9" id="questions" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="questions">Questions?</h1><img src="images/rust-logo-512x512.png" alt="[Rust Logo]"></img></div></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/gotoSlide.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>